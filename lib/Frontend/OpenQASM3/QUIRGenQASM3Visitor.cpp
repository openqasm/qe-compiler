//===- QUIRGenQASM3Visitor.cpp ----------------------------------*- C++ -*-===//
//
// (C) Copyright IBM 2021, 2023.
//
// Any modifications or derivative works of this code must retain this
// copyright notice, and modified files need to carry a notice indicating
// that they have been altered from the originals.
//
//===----------------------------------------------------------------------===//
///
///  The QUIRGenQASM3Visitor will fill a program with mlir statements equivalent
///  to the input from the AST generated by the qss-qasm parser.
///
///  For every ASTExpression or subclass thereof, the QUIRGenQASM3Visitor's
///  visit_ member functions have to return an mlir::Value that represents the
///  (intermediate) value produced by that expression.
///  (WIP, may turn out not to make too much sense).
///
///  This program is stored as an mlir::ModuleOp. This is built and accessed
///  through the private property, `mlir::OpBuilder builder`.
///
///  To add any operation to the program, call the appropriate method on the
///  `builder`.
///  Typically, that would be `builder.create<OpType>(arguments)`. The arguments
///  required depends on the operation. Many can be referenced from LLVM source
///  code. Some basic MLIR operations are found in `include/mlir/IR/Builders.h`.
///  Dialect specific operations, such as QUIR ops or SCF ops, are found in
///  their respective build locations.
///
///  The builder can also be helpful for getting valid mlir Types.
///
//===----------------------------------------------------------------------===//

#include "Dialect/QCS/IR/QCSAttributes.h"
#include "Dialect/QCS/IR/QCSOps.h"

#include <Frontend/OpenQASM3/QUIRGenQASM3Visitor.h>

#include <Frontend/OpenQASM3/BaseQASM3Visitor.h>
#include <Frontend/OpenQASM3/QUIRVariableBuilder.h>

#include <qasm/AST/ASTDelay.h>
#include <qasm/AST/ASTTypeEnums.h>

#include "mlir/Dialect/Arithmetic/IR/Arithmetic.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include <mlir/Dialect/StandardOps/IR/Ops.h>
#include <mlir/IR/Builders.h>
#include <mlir/IR/BuiltinOps.h>

#include <llvm/ADT/StringRef.h>
#include <llvm/ADT/Twine.h>
#include <llvm/Support/Debug.h>
#include <llvm/Support/ErrorHandling.h>

#include <cstdint>
#include <string>
#include <utility>

#define DEBUG_TYPE "QUIRGen"

using namespace mlir;
using namespace mlir::quir;
using namespace mlir::qcs;
using namespace QASM;

namespace qssc::frontend::openqasm3 {

using ExpressionValueType = mlir::Value;

auto QUIRGenQASM3Visitor::getLocation(const ASTBase *node) -> Location {
  return FileLineColLoc::get(builder.getContext(), filename, node->GetLineNo(),
                             node->GetColNo());
}

auto QUIRGenQASM3Visitor::assign(Value &val, const std::string &valName)
    -> bool {
  if (ssaValues.find(valName) != ssaValues.end()) {
    val = ssaValues[valName];
    return true;
  }
  return false;
}

mlir::Value QUIRGenQASM3Visitor::getCurrentValue(const std::string &valueName) {

  auto pos = ssaValues.find(valueName);
  if (pos == ssaValues.end()) {
    llvm::errs() << "Missing SSA assignment for " << valueName << "\n";
    newModule.dump();
    llvm::report_fatal_error("Missing SSA assignment");
  }
  return pos->second;
}

std::string
QUIRGenQASM3Visitor::getExpressionName(const ASTExpressionNode *node) {

  if (const auto *refNode =
          dynamic_cast<const ASTIdentifierRefNode *>(node->GetExpression()))
    return refNode->GetName();
  if (const auto *intNode = dynamic_cast<const ASTIntNode *>(node)) {
    unsigned bits = intNode->GetBits();
    int64_t value = intNode->IsSigned() ? intNode->GetSignedValue()
                                        : intNode->GetUnsignedValue();
    return intNode->GetName() + std::to_string(value) + "_i" +
           std::to_string(bits);
  }
  if (const auto *idNode =
          dynamic_cast<const ASTIdentifierNode *>(node->GetExpression()))
    return idNode->GetName();
  assert(node->GetIdentifier());
  return node->GetIdentifier()->GetName();
}

namespace {
llvm::StringRef getDurationUnitShortName(const QASM::LengthUnit &durationUnit) {
  switch (durationUnit) {
  case Nanoseconds:
    return "ns";
  case Microseconds:
    return "us";
  case Milliseconds:
    return "ms";
  case Seconds:
    return "s";
  case DT:
    return "dt";
  default:
    llvm::errs() << "Unable to understand the Duration unit "
                 << QASM::PrintLengthUnit(durationUnit) << "\n";
    llvm_unreachable("unhandled length unit");
  }
}
}; // anonymous namespace

auto QUIRGenQASM3Visitor::createDurationRef(const Location &location,
                                            uint64_t durationValue,
                                            const LengthUnit &durationUnit)
    -> Value {
  std::string durationString = std::to_string(durationValue);
  llvm::SmallString<32> buf;

  return builder.create<quir::ConstantOp>(
      location,
      DurationAttr::get(builder.getContext(), builder.getType<DurationType>(),
                        durationString +
                            getDurationUnitShortName(durationUnit).str()));
}

void QUIRGenQASM3Visitor::initialize(uint numShots,
                                     const std::string &shotDelay) {
  Location initialLocation =
      FileLineColLoc::get(topLevelBuilder.getContext(), filename, 0, 0);

  // create the "main" function
  auto func = topLevelBuilder.create<FuncOp>(
      initialLocation, "main",
      topLevelBuilder.getFunctionType(
          /*inputs=*/ArrayRef<Type>(),
          /*results=*/ArrayRef<Type>(topLevelBuilder.getI32Type())));

  // set up the builders to point to the proper places
  func.addEntryBlock();
  OpBuilder b(func.getBody());
  builder = b;
  topLevelBuilder.setInsertionPointToStart(topLevelBuilder.getBlock());

  // Initialize the system
  builder.create<SystemInitOp>(initialLocation);

  // create the shot loop
  if (numShots > 1) {
    auto startOp = builder.create<mlir::arith::ConstantOp>(
        initialLocation, builder.getIndexType(), builder.getIndexAttr(0));
    auto endOp = builder.create<mlir::arith::ConstantOp>(
        initialLocation, builder.getIndexType(),
        builder.getIndexAttr(numShots));
    auto stepOp = builder.create<mlir::arith::ConstantOp>(
        initialLocation, builder.getIndexType(), builder.getIndexAttr(1));
    auto forOp =
        builder.create<scf::ForOp>(initialLocation, startOp, endOp, stepOp);
    forOp->setAttr(getShotLoopAttrName(), builder.getUnitAttr());

    builder.setInsertionPointToStart(&forOp.getRegion().front());
    // Add the shot delay to all qubits
    auto duration = builder.create<quir::ConstantOp>(
        initialLocation,
        DurationAttr::get(builder.getContext(), builder.getType<DurationType>(),
                          shotDelay));
    builder.create<DelayOp>(initialLocation, duration, ValueRange({}));
  }
  // init shots even when there's no loop, so we always get a sync_trigger
  auto shotInit = builder.create<ShotInitOp>(initialLocation);
  shotInit->setAttr(getNumShotsAttrName(), builder.getI32IntegerAttr(numShots));

  // reset the insertion pointer to outside the shot loop
  builder.setInsertionPointToEnd(&func.getBody().front());

  // Finalize the system
  builder.create<SystemFinalizeOp>(initialLocation);

  // return 0
  Value intRef = builder.create<mlir::arith::ConstantOp>(
      initialLocation, builder.getIntegerAttr(builder.getIntegerType(32), 0));
  auto returnValueRange = ValueRange(intRef);
  builder.create<mlir::ReturnOp>(initialLocation, returnValueRange);

  // Set the builder to add circuit operations inside the for loop
  builder.setInsertionPointAfter(shotInit);
}

void QUIRGenQASM3Visitor::setInputFile(std::string fName) {
  filename = std::move(fName);
}

mlir::LogicalResult QUIRGenQASM3Visitor::walkAST() {
  BaseQASM3Visitor::walkAST();
  return hasFailed ? mlir::failure() : mlir::success();
}

mlir::InFlightDiagnostic
QUIRGenQASM3Visitor::reportError(ASTBase const *location,
                                 mlir::DiagnosticSeverity severity) {
  DiagnosticEngine &engine = builder.getContext()->getDiagEngine();

  if (severity == mlir::DiagnosticSeverity::Error)
    hasFailed = true;
  return engine.emit(getLocation(location), severity);
}

void QUIRGenQASM3Visitor::visit(const ASTForStatementNode *node) {
  const ASTForLoopNode *loop = node->GetLoop();

  if (loop->GetIVMethod() == ASTForLoopNode::IVMethod::IVDiscrete) {
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Discrete values in a for loop are not yet supported in QUIRGen.";
    // give up handling of this for loop, yet allow QUIRGen to continue (e.g.,
    // to generate further diagnostics)
    return;
  }
  if (loop->GetStepping() < 0) {
    reportError(loop, mlir::DiagnosticSeverity::Error)
        << "Negative stepping values in a for loop are not yet supported in "
           "QUIRGen.";
    // give up handling of this for loop, yet allow QUIRGen to continue (e.g.,
    // to generate further diagnostics)
    return;
  }

  const ASTIntegerList &intList = loop->GetIntegerList();
  Location loc = getLocation(node);

  // Lower bound
  auto startOp = builder.create<mlir::arith::ConstantOp>(
      loc, builder.getIndexType(), builder.getIndexAttr(intList.front()));

  // Upper bound
  // +1 because the SCF dialect has a half-open range, so it does not include
  // the upper bound, whereas OpenQASM3 has an inclusive range, so it includes
  // both the lower bound and the upper bound.
  auto endOp = builder.create<mlir::arith::ConstantOp>(
      loc, builder.getIndexType(), builder.getIndexAttr(intList.back() + 1));

  // Stepping
  auto stepOp = builder.create<mlir::arith::ConstantOp>(
      loc, builder.getIndexType(), builder.getIndexAttr(loop->GetStepping()));

  auto forOp = builder.create<scf::ForOp>(loc, startOp, endOp, stepOp);

  // Adding induction variable to SSA values map
  const ASTIntNode *indVar = loop->GetIndVar();
  Value forOpIndVar = forOp.getInductionVar();
  ssaValues[indVar->GetName()] = forOpIndVar;

  // Dictionary of SSA values used inside "for"
  std::unordered_map<std::string, mlir::Value> forSsaValues = ssaValues;
  // Save previous SSA values so we can restore them outside the for scope
  std::swap(ssaValues, forSsaValues);

  // set up the builders to point to the proper places
  OpBuilder b(&forOp.getRegion());
  builder = b;

  // check inside for loop
  const ASTStatementList &loopNode = loop->GetStatementList();
  BaseQASM3Visitor::visit(&loopNode);

  // Set the builder to add the next operations after the for loop.
  builder.setInsertionPointAfter(forOp);
  std::swap(ssaValues, forSsaValues);
}

void QUIRGenQASM3Visitor::visit(const ASTForLoopNode *node) {
  // This is processed with the ASTForStatementNode.
}

void QUIRGenQASM3Visitor::visit(const ASTIfStatementNode *node) {
  // Checking to see if the IfStatementNode has an else part or not
  bool hasElse = node->HasElse();

  // Create an SSA Value from the if statement condition
  const ASTExpressionNode *exprNode = node->GetExpression();
  Value condition = visitAndGetExpressionValue(exprNode);

  Value conditionBool;
  if (condition.getType() == builder.getI1Type()) {
    conditionBool = condition;
  } else {
    conditionBool = builder.create<CastOp>(getLocation(node),
                                           builder.getI1Type(), condition);
  }

  // Create the if operation
  auto ifOp = builder.create<scf::IfOp>(getLocation(node), conditionBool,
                                        /*withElseRegion=*/hasElse);

  // Save current level OpBuilder
  OpBuilder prevBuilder = builder;

  // Dictionary of SSA values used inside "if"
  std::unordered_map<std::string, mlir::Value> ifSsaValues = ssaValues;
  // Save previous SSA values so we can restore them outside the if scope
  std::swap(ssaValues, ifSsaValues);

  // New OpBuilder for the if statement Region
  OpBuilder ifRegionBuilder(ifOp.getThenRegion());
  builder = ifRegionBuilder;

  // single statement within the if block
  if (const ASTStatementNode *opNode = node->GetOpNode())
    BaseQASM3Visitor::visit(opNode);
  // multiple statements within the if block
  if (const ASTStatementList *opList = node->GetOpList())
    BaseQASM3Visitor::visit(opList);

  // Reset the OpBuilder and SSA values now that we've processed the 'if'
  // statement
  builder = prevBuilder;
  std::swap(ssaValues, ifSsaValues);

  // Else
  if (hasElse) {
    // Dictionary of SSA values used inside "else"
    std::unordered_map<std::string, mlir::Value> elseSsaValues = ssaValues;
    // Save previous SSA values so we can restore them outside the else scope
    std::swap(ssaValues, elseSsaValues);

    // Save current level OpBuilder
    OpBuilder elseBuilder = builder;

    OpBuilder ElseRegionBuilder(ifOp.getElseRegion());
    builder = ElseRegionBuilder;

    // single statement within the else block
    if (const ASTStatementNode *opNode = node->GetElse()->GetOpNode())
      BaseQASM3Visitor::visit(opNode);
    // multiple statements within the else block
    if (const ASTStatementList *opList = node->GetElse()->GetOpList())
      BaseQASM3Visitor::visit(opList);
    // Reset the OpBuilder and SSA values now that we've processed the 'else'
    // statement
    builder = elseBuilder;
    std::swap(ssaValues, elseSsaValues);
  }
}

void QUIRGenQASM3Visitor::visit(const ASTElseStatementNode *node) {
  // This is processed with the ASTIfStatementNode.
}

void QUIRGenQASM3Visitor::visit(const ASTSwitchStatementNode *node) {
  // Getting the number of cases we have
  unsigned caseSize = node->GetNumCaseStatements();
  Location loc = getLocation(node);

  // Getting all the case values
  DenseIntElementsAttr caseValuesAttr;
  SmallVector<uint32_t> caseValues;
  for (auto const &[key, caseStatement] : node->GetCaseStatementsMap())
    caseValues.push_back(caseStatement->GetCaseIndex());
  if (!caseValues.empty())
    caseValuesAttr = DenseIntElementsAttr::get(
        VectorType::get(static_cast<int64_t>(caseValues.size()),
                        builder.getIntegerType(32)),
        caseValues);

  auto caseOperands = node->GetCaseStatementsMap();

  ASTType quantityType = node->GetQuantityType();

  mlir::Value flag;
  switch (quantityType) {
  case ASTTypeInt:
  case ASTTypeUInt:
    flag = visit_(node->GetIntQuantity());
    break;
  case ASTTypeMPInteger:
    flag = visit_(node->GetMPIntegerQuantity());
    break;
  case ASTTypeBinaryOp:
    flag = visit_(node->GetBinaryOpQuantity());
    break;
  case ASTTypeUnaryOp:
    flag = visit_(node->GetUnaryOpQuantity());
    break;
  case ASTTypeIdentifier:
    flag = visit_(node->GetIdentifierQuantity());
    break;
  // TODO: ASTFunctionCallNode is not supported in QUIRGen
  case ASTTypeFunctionCall:
    visit(node->GetFunctionCallQuantity());
    break;
  default:
    break;
  }

  auto switchOp = builder.create<quir::SwitchOp>(
      loc, /*resultTypes=*/mlir::TypeRange{}, flag, caseValuesAttr,
      /*caseRegionsCount=*/caseSize);

  // Save current level OpBuilder
  OpBuilder prevBuilder = builder;

  // Parse the default region.
  Region &defaultRegion = switchOp.defaultRegion();
  defaultRegion.emplaceBlock();
  OpBuilder defaultRegionBuilder(defaultRegion);
  builder = defaultRegionBuilder;
  BaseQASM3Visitor::visit(node->GetDefaultStatement()->GetStatementList());
  // add YieldOp to terminate default regions
  builder.create<quir::YieldOp>(loc);

  // New OpBuilder for the case statement Region
  // adding case regions
  int i = 0;
  for (auto const &[key, caseValue] : node->GetCaseStatementsMap()) {
    Region &caseRegion = switchOp.caseRegions()[i];
    caseRegion.emplaceBlock();
    OpBuilder caseRegionBuilder(caseRegion);
    i++;
    builder = caseRegionBuilder;
    BaseQASM3Visitor::visit(caseValue->GetStatementList());
    // add YieldOp to terminate all case regions
    builder.create<quir::YieldOp>(loc);
  }
  builder = prevBuilder;
}

void QUIRGenQASM3Visitor::visit(const ASTWhileStatementNode *node) {
  const ASTWhileLoopNode *loop = node->GetLoop();
  Location loc = getLocation(node);

  auto whileOp =
      builder.create<scf::WhileOp>(loc, TypeRange({}), ValueRange({}));
  builder.createBlock(&whileOp.getBefore());

  const ASTExpressionNode *exprNode = loop->GetExpression();
  Value condition = visitAndGetExpressionValue(exprNode);

  builder.create<scf::ConditionOp>(loc, condition, ValueRange({}));

  builder.createBlock(&whileOp.getAfter());

  const ASTStatementList &statementList = loop->GetStatementList();
  BaseQASM3Visitor::visit(&statementList);

  builder.create<scf::YieldOp>(loc);
  builder.setInsertionPointAfter(whileOp);
}

void QUIRGenQASM3Visitor::visit(const ASTWhileLoopNode *node) {
  // This is processed with the ASTWhileStatementNode.
}

void QUIRGenQASM3Visitor::visit(const ASTReturnStatementNode *node) {
  reportError(node, mlir::DiagnosticSeverity::Error)
      << "Return statements are not yet supported.";
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTResultNode *node) {
  reportError(node, mlir::DiagnosticSeverity::Error)
      << "Result nodes are not yet supported.";
  return createVoidValue(node);
}

void QUIRGenQASM3Visitor::visit(const ASTFunctionDeclarationNode *node) {
  const ASTFunctionDefinitionNode *funcDef = node->GetDefinition();
  visit(funcDef);
}

void QUIRGenQASM3Visitor::visit(const ASTFunctionDefinitionNode *node) {
  reportError(node, mlir::DiagnosticSeverity::Error)
      << "Subroutine processing is not yet supported in QUIRGen.";
}

void QUIRGenQASM3Visitor::visit(const ASTFunctionCallNode *node) {
  std::vector<Value> operands;
  for (const auto *expr : *node)
    operands.push_back(visitAndGetExpressionValue(
        dynamic_cast<const ASTExpressionNode *>(expr)));
  ValueRange operandRange(operands.data(), operands.size());

  llvm::SmallVector<Type, 1> resultTypes;
  if (node->ReturnsResult())
    resultTypes.emplace_back(
        varHandler.resolveQUIRVariableType(node->GetResult()));
  TypeRange resultRange(resultTypes.data(), resultTypes.size());

  auto callOp = builder.create<CallOp>(getLocation(node), node->GetCallName(),
                                       resultRange, operandRange);

  // fill the expression in case the call result is assigned to something
  expression.reset(); // should be reset, operand visiting above sets expression
  if (node->ReturnsResult())
    expression = callOp->getResult(0); // QASM3 can only return 1 result
}

void QUIRGenQASM3Visitor::visit(const ASTGateDeclarationNode *node) {
  const ASTGateNode *gateNode = node->GetGateNode();

  const size_t numQubits = gateNode->QubitsSize();
  const size_t numParams = gateNode->ParamsSize();
  std::vector<Type> inputs(numQubits + numParams);
  for (unsigned i = 0; i < numQubits; i++)
    inputs[i] = builder.getType<QubitType>(1);
  for (unsigned i = 0; i < numParams; i++) {
    unsigned bits = gateNode->GetParam(i)->GetBits();
    inputs[i + numQubits] = builder.getType<AngleType>(bits);
  }
  auto inputsRef = ArrayRef<Type>(inputs.data(), inputs.size());

  auto func =
      topLevelBuilder.create<FuncOp>(getLocation(node), gateNode->GetName(),
                                     builder.getFunctionType(
                                         /*inputs=*/inputsRef,
                                         /*results=*/ArrayRef<Type>()));
  func.addEntryBlock();

  // TODO this wants to be a symbol table that now enters a new scope
  // Store argument Values so we can reference them within this gate
  std::unordered_map<std::string, mlir::Value> gateSsaValues;
  unsigned i = 0;
  MutableArrayRef<BlockArgument> arguments = func.getBody().getArguments();
  for (BlockArgument *arg = arguments.begin(); arg < arguments.end(); arg++) {
    if (i < numQubits) {
      gateSsaValues[gateNode->GetQubit(i)->GetGateQubitName()] = *arg;
    } else {
      gateSsaValues[gateNode->GetParam(i - numQubits)->GetGateParamName()] =
          *arg;
    }
    i++;
  }

  // Save the current builder, temporarily swap the available Values
  OpBuilder prevBuilder = builder;
  std::swap(ssaValues, gateSsaValues);

  // New OpBuilder for the gate declaration Region
  OpBuilder gateDeclarationBuilder(func.getBody());
  builder = gateDeclarationBuilder;

  const ASTGateQOpList &opList = gateNode->GetOpList();
  for (ASTGateQOpNode *i : opList)
    BaseQASM3Visitor::visit(i);
  builder.create<mlir::ReturnOp>(getLocation(node));

  // Restore SSA Values and OpBuilder as we exit the function
  builder = prevBuilder;
  std::swap(ssaValues, gateSsaValues);
}

void QUIRGenQASM3Visitor::visit(const ASTGenericGateOpNode *node) {
  const ASTGateNode *gateNode = node->GetGateNode();
  visit(gateNode);
}

static const std::string &resolveQCParam(const ASTGateNode *gateNode,
                                         unsigned int index) {
  auto *qcParam = gateNode->GetQCParams()[index];
  auto *qId = qcParam->GetIdentifier();

  assert(qId && "qcParam symbolTableEntry is invalid");
  return qId->GetName();
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTGateNode *node) {
  const size_t numQubits = node->QubitsSize();
  const size_t numParams = node->ParamsSize();
  const size_t numQCParams = node->GetNumQCParams();
  std::vector<Value> args;

  args.reserve(numQubits + numParams + numQCParams);

  for (unsigned i = 0; i < numQubits; i++)
    args.push_back(getCurrentValue(node->GetQubit(i)->GetGateQubitName()));

  for (size_t i = 0; i < numQCParams; i++)
    args.push_back(getCurrentValue(resolveQCParam(node, i)));

  for (unsigned i = 0; i < numParams; i++) {
    const auto *const param = node->GetParam(i);
    if (param->IsExpression()) {
      auto &pos = args.emplace_back();
      // The assign will succeed if the argument is a function/gate def
      // parameter and thus exists in the ssaValues map. If it fails then this
      // must be a normal angle variable use
      if (!assign(pos, param->GetGateParamName())) {
        if (const auto *const ident = param->GetValueIdentifier())
          pos = varHandler.generateVariableUse(getLocation(node), ident);
        else
          reportError(node, mlir::DiagnosticSeverity::Error)
              << "Unnamed expressions not supported by QUIRGen yet, assign to "
                 "an identifier";
      }
    } else {
      args.push_back(visitAndGetExpressionValue(param));
    }
  }

  auto argsValueRange = ValueRange(args.data(), args.size());

  builder.create<CallGateOp>(getLocation(node), node->GetName(), TypeRange{},
                             argsValueRange);
  // no expression value
  return createVoidValue(node);
}

void QUIRGenQASM3Visitor::visit(const ASTHGateOpNode *node) {
  const ASTGateNode *gateNode = node->GetGateNode();
  visit(gateNode);
}

void QUIRGenQASM3Visitor::visit(const ASTUGateOpNode *node) {
  const ASTGateNode *gateNode = node->GetGateNode();
  const size_t numParams = gateNode->ParamsSize();
  constexpr size_t fixedNumParams = 3;
  if (numParams != fixedNumParams) {
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "The U gate takes exactly three parameters, " << numParams
        << " were given.";
    return;
  }

  assert(gateNode->GetNumQubits() == 0 &&
         "assume qubits to be passed in QCParams.");
  assert(gateNode->GetNumQCParams() == 1 &&
         "U gate is a single-qubit gate, expect to have one qubit parameter "
         "only.");

  Value qubitRef = getCurrentValue(resolveQCParam(gateNode, 0));

  std::array<Value, fixedNumParams> angles;
  for (unsigned i = 0; i < fixedNumParams; i++) {
    const auto *const param = gateNode->GetParam(i);
    if (param->IsExpression()) {
      // The assign will succeed if the argument is a function/gate def
      // parameter and thus exists in the ssaValues map. If it fails then this
      // must be a normal angle variable use
      if (!assign(angles[i], param->GetGateParamName())) {
        if (const auto *const ident = param->GetValueIdentifier())
          angles[i] = varHandler.generateVariableUse(getLocation(node), ident);
        else
          reportError(node, mlir::DiagnosticSeverity::Error)
              << "Unnamed expressions not supported by QUIRGen yet, assign to "
                 "an "
                 "identifier";
      }
    } else {
      angles[i] = visitAndGetExpressionValue(param);
    }
  }

  builder.create<Builtin_UOp>(getLocation(node), qubitRef, angles[0], angles[1],
                              angles[2]);
}

void QUIRGenQASM3Visitor::visit(const ASTCXGateOpNode *node) {
  const ASTGateNode *gateNode = node->GetGateNode();

  assert(gateNode->GetNumQCParams() == 2 && "expect 2 qubit parameters.");

  Value controlQubit = getCurrentValue(resolveQCParam(gateNode, 0));
  Value targetQubit = getCurrentValue(resolveQCParam(gateNode, 1));

  builder.create<BuiltinCXOp>(getLocation(node), controlQubit, targetQubit);
}

void QUIRGenQASM3Visitor::visit(const ASTResetNode *node) {
  Value qubitRef = getCurrentValue(node->GetTarget()->GetName());
  builder.create<ResetQubitOp>(getLocation(node), qubitRef);
}

mlir::Value QUIRGenQASM3Visitor::createMeasurement(const ASTMeasureNode *node,
                                                   bool emitAssignment) {
  unsigned targetSize = node->GetTargetSize();
  unsigned resultSize = node->GetResultSize();
  // This means that the target/result wasn't an array, but a single qubit/bit.
  if (targetSize == 0)
    targetSize = 1;
  if (resultSize == 0)
    resultSize = 1;
  if (targetSize != resultSize) {
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "The number of qubits and result bits for this measurement are "
           "mismatched.";
    // allow QUIRGen to continue for now with a dummy value, to potentially
    // provide further diagnostics
    return builder.create<mlir::arith::ConstantOp>(getLocation(node),
                                                   builder.getBoolAttr(false));
  }

  // note: earlier revisions of this function may have suggested that it could
  // measure qubit registers into classical registers, yet it could not: it
  // would have measured the same qubit multiple times.
  if (targetSize > 1) {
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Measurement statements for more than one qubit at a time are not "
           "supported yet.";
    return builder.create<mlir::arith::ConstantOp>(getLocation(node),
                                                   builder.getBoolAttr(false));
  }

  const ASTQubitContainerNode *qubitsNode = node->GetTarget();
  Value qubitRef = getCurrentValue(qubitsNode->GetName());
  auto measureOp = builder.create<MeasureOp>(getLocation(node),
                                             builder.getI1Type(), qubitRef);
  if (emitAssignment) {
    auto *target = node->GetResult();
    unsigned resultIndex =
        node->GetResultSize() == 0 ? 0 : node->GetResultIndex(0);
    auto *identifier = target->GetIdentifier();

    if (identifier->GetASTType() == ASTTypeIdentifierRef) {
      const auto *refnode =
          dynamic_cast<const ASTIdentifierRefNode *>(identifier);
      assert(refnode && "ASTIdentifierNode of ASTTYpe ASTTypeIdentifierRef "
                        "should also be an ASTIdentifierRefNode");
      identifier = refnode->GetIdentifier();
    }

    varHandler.generateCBitSingleBitAssignment(
        getLocation(node), identifier->GetName(), measureOp.outs().front(),
        resultIndex, identifier->GetBits());
  }

  return measureOp.outs().front();
}

void QUIRGenQASM3Visitor::visit(const ASTMeasureNode *node) {
  createMeasurement(node, true);
}

void QUIRGenQASM3Visitor::visit(const ASTDelayStatementNode *node) {
  const ASTDelayNode *delayNode = node->GetDelay();

  switch (delayNode->GetDelayType()) {
  case ASTTypeDuration: {
    // duration a = 10ns; delay[a] $q;
    Value duration = getCurrentValue(delayNode->GetDurationNode()->GetName());
    Value qubitRef =
        getCurrentValue(delayNode->GetDelayQubitIdentifier()->GetName());

    builder.create<DelayOp>(getLocation(delayNode), duration, qubitRef);
    break;
  }
  case ASTTypeQubit: {
    // delay[10ns] $q;
    // delay[10ns] $0, $1;
    const auto durationRef =
        createDurationRef(getLocation(delayNode), delayNode->GetDuration(),
                          delayNode->GetLengthUnit());

    const ASTIdentifierList &idList = delayNode->GetOperandList();
    const size_t numQubits = idList.Size();
    std::vector<Value> args(numQubits);
    unsigned i = 0;
    for (ASTIdentifierNode *idNode : idList) {
      args[i] = getCurrentValue(idNode->GetName());
      i++;
    }
    auto argsValueRange = ValueRange(args.data(), args.size());
    builder.create<DelayOp>(getLocation(node), durationRef, argsValueRange);
    break;
  }
  case ASTTypeStretch: {
    // stretch a; delay[a] $q;
    // stretch a; delay[a] $0, $1;
    Value stretchRef = getCurrentValue(
        delayNode->GetStretchNode()->GetIdentifier()->GetName());

    const ASTIdentifierList &idList = delayNode->GetOperandList();
    const size_t numQubits = idList.Size();
    std::vector<Value> args(numQubits);
    unsigned i = 0;
    for (ASTIdentifierNode *idNode : idList) {
      args[i] = getCurrentValue(idNode->GetName());
      i++;
    }
    auto argsValueRange = ValueRange(args.data(), args.size());
    builder.create<DelayOp>(getLocation(node), stretchRef, argsValueRange);
    break;
  }
  default:
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Cannot process " << PrintTypeEnum(delayNode->GetDelayType())
        << " delay node.";
    return;
  }
}

void QUIRGenQASM3Visitor::visit(const ASTBarrierNode *node) {
  const ASTIdentifierList &idList = node->GetOperandList();
  const size_t numQubits = idList.Size();
  std::vector<Value> args(numQubits);
  unsigned i = 0;
  for (ASTIdentifierNode *idNode : idList) {
    args[i] = getCurrentValue(idNode->GetName());
    i++;
  }
  auto argsValueRange = ValueRange(args.data(), args.size());
  builder.create<BarrierOp>(getLocation(node), argsValueRange);
}

void QUIRGenQASM3Visitor::visit(const ASTDeclarationNode *node) {
  const ASTIdentifierNode *idNode = node->GetIdentifier();
  const mlir::Location loc = getLocation(node);

  switch (node->GetASTType()) {
  case ASTTypeMPInteger:
  case ASTTypeInt:
  case ASTTypeBool:
  case ASTTypeBitset:
  case ASTTypeAngle:
  case ASTTypeFloat:
  case ASTTypeMPDecimal:
  case ASTTypeMPComplex: {
    auto variableType = varHandler.resolveQUIRVariableType(node);
    auto val = visitAndGetExpressionValue(node->GetExpression());

    varHandler.generateVariableDeclaration(
        loc, idNode->GetName(), variableType,
        node->GetModifierType() == QASM::ASTTypeInputModifier,
        node->GetModifierType() == QASM::ASTTypeOutputModifier);

    // generate variable assignment so that they are reinitialized on every
    // shot.
    varHandler.generateVariableAssignment(loc, idNode->GetName(), val);
    return;
  }

  case ASTTypeKernelDeclaration:
    visit(dynamic_cast<const ASTKernelDeclarationNode *>(node));
    return;

  default:
    break;
  }

  // otherwise, look up node in sym table (old path, to be removed)
  BaseQASM3Visitor::visit(idNode->GetSymbolTableEntry());
}

void QUIRGenQASM3Visitor::visit(const ASTKernelDeclarationNode *node) {
  visit(node->GetKernel());
  return;
}

void QUIRGenQASM3Visitor::visit(const ASTKernelNode *node) {
  const auto &params = node->GetParameters();
  const size_t numParams = params.size();
  llvm::SmallVector<Type> inputs(numParams);
  for (const auto &[index, declNode] : params)
    inputs[index] = getQUIRTypeFromDeclaration(declNode);
  auto inputsRef = ArrayRef<Type>(inputs.data(), inputs.size());

  assert(node->HasResult() && "Every kernel node must have a return node");
  llvm::SmallVector<Type> outputs;
  if (!node->GetResult()->IsVoid())
    outputs.emplace_back(varHandler.resolveQUIRVariableType(node->GetResult()));
  auto outputsRef = ArrayRef<Type>(outputs.data(), outputs.size());

  llvm::SmallVector<NamedAttribute, 1> attrs;
  attrs.emplace_back(
      builder.getStringAttr(SymbolTable::getVisibilityAttrName()),
      builder.getStringAttr("private"));
  ArrayRef<NamedAttribute> funcAttrs(attrs.data(), attrs.size());

  topLevelBuilder.create<FuncOp>(
      getLocation(node), node->GetName(),
      builder.getFunctionType(/*inputs=*/inputsRef, /*results=*/outputsRef),
      /*attrs=*/funcAttrs);
  return;
}

Type QUIRGenQASM3Visitor::getQUIRTypeFromDeclaration(
    const ASTDeclarationNode *node) {
  switch (node->GetASTType()) {
  case ASTTypeMPInteger:
  case ASTTypeInt:
  case ASTTypeBool:
  case ASTTypeBitset:
  case ASTTypeAngle:
  case ASTTypeFloat:
  case ASTTypeMPDecimal:
  case ASTTypeMPComplex: {
    return varHandler.resolveQUIRVariableType(node);
  }
  default:
    break;
  }

  reportError(node, mlir::DiagnosticSeverity::Error)
      << "Unknown Declaration Type, cannot convert to QUIR Type.";
  return builder.getNoneType();
}

ExpressionValueType
QUIRGenQASM3Visitor::visit_(const ASTQubitContainerNode *node) {
  const std::string &qId = node->GetName();
  int id = stoi(node->GetIdentifier()->GetQubitMnemonic());

  const unsigned size = node->Size();
  Value qubitRef = builder
                       .create<DeclareQubitOp>(
                           getLocation(node), builder.getType<QubitType>(size),
                           builder.getIntegerAttr(builder.getI32Type(), id))
                       .res();
  ssaValues[qId] = qubitRef;
  return qubitRef;
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTQubitNode *node) {
  // Nothing to do here.
  return createVoidValue(node);
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTCBitNode *node) {
  LLVM_DEBUG(llvm::dbgs() << "ASTCBitNode \"" << node->AsString() << "\" size "
                          << node->Size() << " strlen "
                          << node->AsString().size() << "\n");
  assert(node->GetIdentifier());

  // The name "bitset" indicates that this node represents an unnamed value.
  // Otherwise, this node represents the use of a variable.
  if (node->GetName() != "bitset" &&
      node->GetIdentifier()->HasSymbolTableEntry() &&
      varHandler.tracksVariable(node->GetName())) {
    // this node is a reference to a variable
    return varHandler.generateVariableUse(getLocation(node),
                                          node->GetIdentifier());
  }

  // detect and handle the case of initializing a classical bit with a
  // measurement
  if (const auto *nodeGateOp =
          dynamic_cast<const ASTMeasureNode *>(node->GetGateQOp())) {
    if (node->Size() > 1) {
      reportError(nodeGateOp, mlir::DiagnosticSeverity::Error)
          << "Measurement for initialization is only supported "
             "for single classical bits.";
      // dummy value
      return builder.create<mlir::arith::ConstantOp>(
          getLocation(node), builder.getBoolAttr(false));
    }
    auto measurement = createMeasurement(nodeGateOp, false);
    return builder.create<mlir::quir::CastOp>(
        getLocation(node), builder.getType<mlir::quir::CBitType>(1),
        measurement);
  }

  // the node's string respresentation may be shorter or longer than the
  // classical bit expression, so truncate to trailing (least-significant bits)
  // or take full string
  auto stringRepr = llvm::StringRef(node->AsString()).take_back(node->Size());
  llvm::APInt initializer(node->Size(), stringRepr, /* radix */ 2);

  // build an arbitrary-precision integer and let QUIR_CastOp take care of
  // initializing a classical register value from it.
  auto location = getLocation(node);
  auto initializerVal = builder.create<mlir::arith::ConstantOp>(
      location, builder.getIntegerAttr(builder.getIntegerType(node->Size()),
                                       initializer));

  return builder.create<mlir::quir::CastOp>(
      location, builder.getType<mlir::quir::CBitType>(node->Size()),
      initializerVal);
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTDurationNode *node) {
  // TODO this node may refer to an identifier, not just the encoded value. Fix
  // when replacing the use of ssaValues.
  assert((ssaValues.find(node->GetName()) == ssaValues.end()) &&
         "ASTDurationNode referring to a previously declared duration is not "
         "supported yet.");

  const auto durationRef = createDurationRef(
      getLocation(node), node->GetDuration(), node->GetLengthUnit());

  ssaValues[node->GetName()] = durationRef;
  return durationRef;
}

void QUIRGenQASM3Visitor::visit(const ASTStretchStatementNode *node) {
  const ASTStretchNode *stretchNode = node->GetStretch();
  visit(stretchNode);
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTStretchNode *node) {
  // TODO this node may refer to an identifier, not just the encoded value. Fix
  // when replacing the use of ssaValues.
  // TODO: handling of stretch is broken.

  const Value stretchRef = builder.create<DeclareStretchOp>(
      getLocation(node), builder.getType<StretchType>());
  ssaValues[node->GetName()] = stretchRef;
  return stretchRef;
}

ExpressionValueType
QUIRGenQASM3Visitor::visit_(const ASTIdentifierRefNode *node) {
  unsigned index = node->IsIndexed() ? node->GetIndex() : 0;
  std::string const &variableName = node->GetIdentifier()->GetName();

  if (varHandler.tracksVariable(variableName)) {
    ASTSymbolTableEntry const *symTableEntry =
        node->GetIdentifier()->GetSymbolTableEntry();

    if (symTableEntry->GetValueType() == QASM::ASTTypeBitset &&
        node->IsIndexed()) {
      // single cbit out of a cbit register
      auto cbit = varHandler.generateVariableUse(getLocation(node),
                                                 variableName, symTableEntry);
      return builder.create<quir::Cbit_ExtractBitOp>(
          getLocation(node), builder.getI1Type(), cbit,
          builder.getIndexAttr(node->GetIndex()));
    }

    if (node->IsIndexed())
      return varHandler.generateArrayVariableElementUse(
          getLocation(node), variableName, node->GetIndex(), symTableEntry);
  }

  // TODO replace old case, incorrect handling
  Value memRef = getCurrentValue(variableName);

  Value indexRef = builder.create<mlir::arith::ConstantOp>(
      getLocation(node), builder.getIndexAttr(index));

  Value loadOpRef =
      builder.create<mlir::memref::LoadOp>(getLocation(node), memRef, indexRef);
  ssaValues[node->GetName()] = loadOpRef;
  return loadOpRef;
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTIdentifierNode *node) {
  llvm::StringRef variableName = node->GetName();
  mlir::Location location = getLocation(node);

  // old-style variable (i.e., still broken?!)
  if (!varHandler.tracksVariable(variableName))
    return getCurrentValue(node->GetName());

  return varHandler.generateVariableUse(location, node);
}

using mlir::arith::CmpIPredicate;

static CmpIPredicate getComparisonPredicate(QASM::ASTOpType opType) {
  switch (opType) {
  case ASTOpTypeCompEq:
    return CmpIPredicate::eq;
  case ASTOpTypeCompNeq:
    return CmpIPredicate::ne;
  case ASTOpTypeLT:
    return CmpIPredicate::slt;
  case ASTOpTypeLE:
    return CmpIPredicate::sle;
  case ASTOpTypeGT:
    return CmpIPredicate::sgt;
  case ASTOpTypeGE:
    return CmpIPredicate::sge;

  default:
    llvm::errs() << "Cannot derive comparison predicate for opType "
                 << QASM::PrintOpTypeEnum(opType) << "\n";
    llvm_unreachable("Unimplemented.");
  }
}

ExpressionValueType
QUIRGenQASM3Visitor::handleAssign(const ASTBinaryOpNode *node) {
  const Location location = getLocation(node);
  const ASTExpressionNode *left = node->GetLeft();
  const ASTExpressionNode *right = node->GetRight();

  Value rightRef = visitAndGetExpressionValue(right);

  if (left->GetASTType() != ASTTypeIdentifier) {
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Cannot handle assignment to " << getExpressionName(left)
        << " which is not an identifier";
    return createVoidValue(node);
  }

  auto *identifier = left->GetIdentifier();
  bool isIndexed = false;
  size_t index = 0;

  if (left->IsIdentifier() && left->GetIdentifier()->IsReference()) {
    auto const *idRefNode =
        dynamic_cast<const ASTIdentifierRefNode *>(left->GetIdentifier());
    identifier = idRefNode->GetIdentifier();
    isIndexed = idRefNode->IsIndexed();
    index = idRefNode->GetIndex();
  }

  llvm::StringRef const variableName = identifier->GetName();

  // old & incorrect handling, TODO handle all variables the new way and remove.
  if (!left->IsIdentifier() || !varHandler.tracksVariable(variableName)) {
    Value leftRef = visitAndGetExpressionValue(left);

    Value opRef = rightRef;
    if (leftRef.getType() != rightRef.getType()) {
      opRef = builder.create<CastOp>(getLocation(left), leftRef.getType(),
                                     rightRef);
    }
    ssaValues[left->GetIdentifier()->GetName()] = opRef;
    return opRef;
  }

  Value operand = rightRef;
  assert(identifier->HasSymbolTableEntry() &&
         "failed walking to the right identifier, or the identifier is missing "
         "its reference to the symbol table");
  auto const *symTableEntry = identifier->GetSymbolTableEntry();
  assert(symTableEntry);

  mlir::Type variableType = varHandler.resolveQUIRVariableType(symTableEntry);
  llvm::ArrayRef<int64_t> shape{};
  if (auto tensorType = variableType.dyn_cast<TensorType>()) {
    shape = tensorType.getShape();
    variableType = tensorType.getElementType();
  }

  if (variableType.isa<quir::CBitType>() && isIndexed) {
    // insert single bit into cbit register
    if (rightRef.getType() != builder.getI1Type())
      operand = builder.create<CastOp>(getLocation(left), builder.getI1Type(),
                                       rightRef);

    varHandler.generateCBitSingleBitAssignment(
        getLocation(node), variableName, operand, index,
        variableType.dyn_cast<mlir::quir::CBitType>().getWidth());
    return operand;
  }

  if (variableType != rightRef.getType())
    operand = builder.create<CastOp>(getLocation(left), variableType, rightRef);

  if (isIndexed) {
    varHandler.generateArrayVariableElementAssignment(location, variableName,
                                                      operand, index);
  } else {
    varHandler.generateVariableAssignment(getLocation(left), variableName,
                                          operand);
  }
  return operand;
}

mlir::Value
QUIRGenQASM3Visitor::visitAndGetExpressionValue(const ASTExpressionNode *node) {
  expression.reset();
  BaseQASM3Visitor::visit(node);

  if (!expression.hasValue()) {
    llvm::errs() << "Error: visiting node " << PrintTypeEnum(node->GetASTType())
                 << " " << node << " failed to return an expression\n";
    llvm::errs() << getLocation(node) << "\n";
    llvm_unreachable("no expression returned by visitor!");
  }

  return expression.getValue();
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTBinaryOpNode *node) {
  // some op types are handled separately
  switch (node->GetOpType()) {

  case ASTOpTypeAssign:
    return handleAssign(node);

  default:
    break;
  }

  const ASTExpressionNode *left = node->GetLeft();
  const ASTExpressionNode *right = node->GetRight();

  mlir::Value leftRef = visitAndGetExpressionValue(left);
  mlir::Value rightRef = visitAndGetExpressionValue(right);

  Type leftType = leftRef.getType();
  Type rightType = rightRef.getType();

  const Location loc = getLocation(node);
  const auto boolType = builder.getI1Type();

  size_t bits = 0;

  if (leftType.isa<quir::CBitType>())
    bits = std::max(bits, (size_t)leftType.cast<quir::CBitType>().getWidth());
  if (leftType.isIntOrFloat())
    bits = std::max(bits, (size_t)leftType.getIntOrFloatBitWidth());
  if (rightType.isa<quir::CBitType>())
    bits = std::max(bits, (size_t)rightType.cast<quir::CBitType>().getWidth());
  if (rightType.isIntOrFloat())
    bits = std::max(bits, (size_t)rightType.getIntOrFloatBitWidth());

  LLVM_DEBUG(llvm::dbgs() << "binary op "
                          << QASM::PrintOpTypeEnum(node->GetOpType())
                          << " between\n");
  LLVM_DEBUG(llvm::dbgs() << "  lhs (ASTTYpe "
                          << QASM::PrintTypeEnum(left->GetASTType()) << ") "
                          << leftRef << "\n");
  LLVM_DEBUG(llvm::dbgs() << "  rhs (ASTTYpe "
                          << QASM::PrintTypeEnum(right->GetASTType()) << ") "
                          << rightRef << "\n");
  LLVM_DEBUG(llvm::dbgs() << "  common bit width " << bits << "\n");
  LLVM_DEBUG(llvm::dbgs() << "  at " << loc << "\n");

  // check and potentially cast types
  switch (node->GetOpType()) {
  case ASTOpTypeCompEq:
  case ASTOpTypeCompNeq:
  case ASTOpTypeLT:
  case ASTOpTypeLE:
  case ASTOpTypeGT:
  case ASTOpTypeGE:
    // cast classical bit registers, if required
    if (leftType.isa<quir::CBitType>()) {
      leftRef = builder.create<CastOp>(getLocation(left),
                                       builder.getIntegerType(bits), leftRef);
    }
    if (rightType.isa<quir::CBitType>()) {
      rightRef = builder.create<CastOp>(getLocation(right),
                                        builder.getIntegerType(bits), rightRef);
    }
    // integer types of different sizes
    if (leftType != rightType && leftType.isIntOrIndex() &&
        rightType.isIntOrIndex()) {
      if (leftType.getIntOrFloatBitWidth() <
          rightType.getIntOrFloatBitWidth()) {
        leftRef = builder.create<CastOp>(getLocation(left), rightType, leftRef);
      } else {
        rightRef =
            builder.create<CastOp>(getLocation(right), leftType, rightRef);
      }
    }
    break;

  case ASTOpTypeLogicalAnd:
  case ASTOpTypeLogicalOr:
    assert(leftType == boolType);
    assert(rightType == boolType);
    break;

  default:
    // nothing to do for other ops
    break;
  }

  // lambda function for checking type mismatch
  auto createCastIfTypeMismatch = [&]() {
    // cast in case of IndexType
    if (leftType != rightType && (leftType.isIndex() || rightType.isIndex())) {
      if (leftType.isIndex())
        leftRef = builder.create<CastOp>(getLocation(left), rightType, leftRef);
      else
        rightRef =
            builder.create<CastOp>(getLocation(right), leftType, rightRef);
    }
  };

  Value opRef;

  switch (node->GetOpType()) {
  case ASTOpTypeLogicalOr:
    opRef = builder.create<mlir::arith::OrIOp>(loc, leftRef, rightRef);
    break;

  case ASTOpTypeLogicalAnd:
    opRef = builder.create<mlir::arith::AndIOp>(loc, leftRef, rightRef);
    break;

  case ASTOpTypeBitAnd:
    createCastIfTypeMismatch();
    opRef = builder.create<mlir::quir::Cbit_AndOp>(loc, leftRef, rightRef);
    break;

  case ASTOpTypeBitOr:
    createCastIfTypeMismatch();
    opRef = builder.create<mlir::quir::Cbit_OrOp>(loc, leftRef, rightRef);
    break;

  case ASTOpTypeXor:
    createCastIfTypeMismatch();
    opRef = builder.create<mlir::quir::Cbit_XorOp>(loc, leftRef, rightRef);
    break;

  case ASTOpTypeCompEq:
  case ASTOpTypeCompNeq:
  case ASTOpTypeLT:
  case ASTOpTypeLE:
  case ASTOpTypeGT:
  case ASTOpTypeGE:
    opRef = builder.create<mlir::arith::CmpIOp>(
        loc, getComparisonPredicate(node->GetOpType()), leftRef, rightRef);
    break;

  default:
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Binary operation " << QASM::PrintOpTypeEnum(node->GetOpType())
        << " not supported yet.";
    return createVoidValue(node);
  }

  return opRef;
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTUnaryOpNode *node) {

  const ASTOperatorNode *operatorNode = nullptr;

  switch (node->GetOpType()) {
  case ASTOpTypeLogicalNot:
    assert(node->GetExpression()->GetASTType() == QASM::ASTTypeOpTy);
    operatorNode = dynamic_cast<const ASTOperatorNode *>(node->GetExpression());
    assert(operatorNode && "mismatch of ASTType and class");
    assert(operatorNode->GetOpType() == ASTOpTypeLogicalNot);
    break;

  default:
    std::ostringstream oss;
    oss << "Operator" << QASM::PrintOpTypeOperator(node->GetOpType())
        << " is not supported.\n";
    throw std::runtime_error(oss.str());
  }

  assert(operatorNode);

  const Location loc = getLocation(node);
  mlir::Value targetValue;

  if (operatorNode->IsExpression()) {
    targetValue =
        visitAndGetExpressionValue(operatorNode->GetTargetExpression());
  } else {
    const auto *id = operatorNode->GetTargetIdentifier();
    assert(id &&
           "ASTOperatorNode's target must be either expression or identifier.");

    if (id->IsReference()) {
      const auto *idRef = dynamic_cast<const ASTIdentifierRefNode *>(id);
      targetValue = visitAndGetExpressionValue(idRef);
    } else {
      targetValue =
          visitAndGetExpressionValue(operatorNode->GetTargetIdentifier());
    }
  }

  switch (node->GetOpType()) {
  case ASTOpTypeLogicalNot: {
    const auto boolType = builder.getI1Type();

    // targetValue will have the type of the subexpression that the logical not
    // operates on (by means of type synthesis / type as a synthesized
    // attribute). for integer types and classical bit registers, introduce a
    // cast to bool before applying the logical not.
    if (targetValue.getType() != boolType) {
      // other types are not allowed for a logical not.
      if (!targetValue.getType().isIntOrIndex() &&
          !targetValue.getType().isa<quir::CBitType>())
        // TODO proper diagnostic
        throw std::runtime_error("invalid type for operator logical not.");
      targetValue = builder.create<CastOp>(loc, boolType, targetValue);
    }

    auto constantTrue =
        builder.create<mlir::arith::ConstantOp>(loc, builder.getBoolAttr(true));

    return builder.create<mlir::arith::CmpIOp>(loc, CmpIPredicate::ne,
                                               targetValue, constantTrue);
  }

  default:
    llvm_unreachable("unimplemented operators should be caught above!");
  }
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTIntNode *node) {
  assert(node->GetIdentifier());

  if (node->GetIdentifier()->HasSymbolTableEntry() &&
      node->GetName() != "int" && varHandler.tracksVariable(node->GetName())) {
    // this node is a reference to a variable

    assert(node->GetIdentifier()->GetSymbolTableEntry());
    return varHandler.generateVariableUse(getLocation(node),
                                          node->GetIdentifier());
  }

  const unsigned bits = node->GetBits();
  int64_t value =
      node->IsSigned() ? node->GetSignedValue() : node->GetUnsignedValue();

  return builder.create<mlir::arith::ConstantOp>(
      getLocation(node),
      builder.getIntegerAttr(builder.getIntegerType(bits), value));
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTMPIntegerNode *node) {
  assert(node->GetIdentifier());

  if (node->GetIdentifier()->HasSymbolTableEntry() &&
      node->GetName() != "mpinteger" &&
      varHandler.tracksVariable(node->GetName())) {
    // this node is a reference to a variable

    assert(node->GetIdentifier()->GetSymbolTableEntry());
    return varHandler.generateVariableUse(getLocation(node),
                                          node->GetIdentifier());
  }

  std::string name = getExpressionName(node);
  const unsigned bits = node->GetBits();
  bool isSigned = node->IsSigned();
  int64_t value = isSigned ? node->ToSignedInt() : node->ToUnsignedInt();

  return builder.create<mlir::arith::ConstantOp>(
      getLocation(node),
      builder.getIntegerAttr(builder.getIntegerType(bits), value));
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTFloatNode *node) {
  // TODO this node may refer to an identifier, not just the encoded value. Fix
  // when replacing the use of ssaValues.
  assert(!varHandler.tracksVariable(node->GetName()) &&
         "ASTDurationNode referring to a previously declared duration is not "
         "supported yet.");

  const unsigned bits = node->GetBits();
  double value = node->GetValue();

  // MLIR does not support arbitrary precision float types
  mlir::Type type;
  switch (bits) {
  case 16:
    type = builder.getF16Type();
    break;
  case 32:
    type = builder.getF32Type();
    break;
  case 64:
    type = builder.getF64Type();
    break;
  case 80:
    type = builder.getF80Type();
    break;
  case 128:
    type = builder.getF128Type();
    break;
  default:
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Float type of precision " << bits << " bits is unsupported";
    // dummy value to allow processing remainder of AST
    return builder.create<mlir::arith::ConstantOp>(
        getLocation(node), builder.getF16FloatAttr(0.0));
  }

  return builder.create<mlir::arith::ConstantOp>(
      getLocation(node), builder.getFloatAttr(type, value));
}

ExpressionValueType
QUIRGenQASM3Visitor::getValueFromLiteral(const ASTMPDecimalNode *node) {
  const unsigned bits = node->GetIdentifier()->GetBits();
  double long value = 0.0;
  if (node->IsNumber())
    value = node->ToLongDouble();

  FloatType floatType;
  if (bits <= 16) {
    floatType = builder.getF16Type();
  } else if (bits <= 32) {
    floatType = builder.getF32Type();
  } else if (bits <= 64) {
    floatType = builder.getF64Type();
  } else if (bits <= 80) {
    floatType = builder.getF80Type();
  } else if (bits <= 128) {
    floatType = builder.getF128Type();
  } else {
    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Cannot support float with " << bits << " bits";
    // dummy value to allow processing remainder of AST
    return builder.create<mlir::arith::ConstantOp>(
        getLocation(node), builder.getF16FloatAttr(0.0));
  }

  return builder.create<mlir::arith::ConstantOp>(
      getLocation(node), builder.getFloatAttr(floatType, value));
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTMPDecimalNode *node) {
  // TODO this node may refer to an identifier, not just the encoded value. Fix
  // when replacing the use of ssaValues.
  assert((ssaValues.find(node->GetName()) == ssaValues.end()) &&
         "ASTMPDecimalNode referring to a previously declared duration is not "
         "supported yet.");

  return getValueFromLiteral(node);
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTMPComplexNode *node) {
  // TODO this node may refer to an identifier, not just the encoded value. Fix
  // when replacing the use of ssaValues.
  std::string name = getExpressionName(node);

  assert((ssaValues.find(name) == ssaValues.end()) &&
         "ASTMPComplexNode referring to a previously declared duration is not "
         "supported yet.");

  Value real = getValueFromLiteral(node->GetRealAsMPDecimal());
  Value imag = getValueFromLiteral(node->GetImagAsMPDecimal());

  return builder.create<complex::CreateOp>(
      getLocation(node), ComplexType::get(real.getType()), real, imag);
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTAngleNode *node) {
  assert(node->GetIdentifier());

  if (node->GetIdentifier()->HasSymbolTableEntry() &&
      node->GetName() != "angle" &&
      varHandler.tracksVariable(node->GetName())) {
    // this node is a reference to a variable

    assert(node->GetIdentifier()->GetSymbolTableEntry());
    return varHandler.generateVariableUse(getLocation(node),
                                          node->GetIdentifier());
  }

  const unsigned bits = node->GetBits();
  double value = 0.0;
  if (!node->IsNan())
    value = node->AsDouble();

  return builder.create<quir::ConstantOp>(
      getLocation(node),
      AngleAttr::get(builder.getContext(), builder.getType<AngleType>(bits),
                     llvm::APFloat(value)));
}

ExpressionValueType QUIRGenQASM3Visitor::visit_(const ASTBoolNode *node) {
  assert(node->GetIdentifier());

  if (node->GetIdentifier()->HasSymbolTableEntry() &&
      node->GetName() != "bool" && varHandler.tracksVariable(node->GetName())) {
    // this node is a reference to a variable

    assert(node->GetIdentifier()->GetSymbolTableEntry());
    return varHandler.generateVariableUse(
        getLocation(node), node->GetName(),
        node->GetIdentifier()->GetSymbolTableEntry());
  }

  Value boolRef = builder.create<mlir::arith::ConstantOp>(
      getLocation(node), builder.getBoolAttr(node->GetValue()));
  return boolRef;
}

Type QUIRGenQASM3Visitor::getCastDestinationType(
    const ASTCastExpressionNode *node, mlir::OpBuilder &builder) {
  switch (node->GetCastTo()) {
  case ASTTypeBool:
    return builder.getI1Type();

  default:

    reportError(node, mlir::DiagnosticSeverity::Error)
        << "Unsupported cast destination type "
        << PrintTypeEnum(node->GetCastTo());

    return builder.getNoneType();
  }
}

ExpressionValueType
QUIRGenQASM3Visitor::visit_(const ASTCastExpressionNode *node) {
  // visiting the child expression is deferred to BaseQASM3Visitor
  expression.reset();
  BaseQASM3Visitor::visit(node);
  assert(expression.hasValue() && "failed to get expression value from child");
  mlir::Value operandRef = expression.getValue();

  Value opRef = builder.create<CastOp>(
      getLocation(node), getCastDestinationType(node, builder), operandRef);
  ssaValues[node->GetIdentifier()->GetName()] = opRef;
  return opRef;
}

mlir::Value QUIRGenQASM3Visitor::createVoidValue(mlir::Location location) {
  return builder.create<mlir::ConstantOp>(location, builder.getUnitAttr());
}

mlir::Value QUIRGenQASM3Visitor::createVoidValue(QASM::ASTBase const *node) {
  return createVoidValue(getLocation(node));
}

} // namespace qssc::frontend::openqasm3
