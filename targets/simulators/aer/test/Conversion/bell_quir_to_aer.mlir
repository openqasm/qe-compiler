// RUN: echo "{}" > %t
// RUN: qss-compiler -X=mlir --emit=mlir --target aer-simulator --config %t %s --simulator-quir-to-aer | FileCheck %s

//
// This file was generated by:
// $ qss-compiler -X=mlir --emit=mlir --target aer-simulator --config test.cfg bell.qasm \
// $   --simulator-output-cregs --quir-eliminate-variables
//

//
// This code is part of Qiskit.
//
// (C) Copyright IBM 2023.
//
// This code is licensed under the Apache License, Version 2.0 with LLVM
// Exceptions. You may obtain a copy of this license in the LICENSE.txt
// file in the root directory of this source tree.
//
// Any modifications or derivative works of this code must retain this
// copyright notice, and modified files need to carry a notice indicating
// that they have been altered from the originals.
//

module {
  llvm.mlir.global private constant @str_creg_c1("  c1 : \00")
  llvm.mlir.global private constant @str_creg_c0("  c0 : \00")
  llvm.mlir.global private constant @str_digit("%d\00")
  llvm.mlir.global private constant @str_endline("\0A\00")
  llvm.func @printf(!llvm.ptr<i8>, ...) -> i32
  func @cx(%arg0: !quir.qubit<1>, %arg1: !quir.qubit<1>) {
    return
  }
  func @main() -> i32 {

    // CHECK: {{.*}} = llvm.call @aer_state() : () -> !llvm.ptr<i8>

    %angle = quir.constant #quir.angle<1.57079632679 : !quir.angle<64>>
    %angle_0 = quir.constant #quir.angle<0.000000e+00 : !quir.angle<64>>
    %angle_1 = quir.constant #quir.angle<3.1415926535900001 : !quir.angle<64>>
    // CHECK: %[[angle:.*]] = arith.constant 1.57079632679 : f64
    // CHECK: %[[angle0:.*]] = arith.constant 0.000000e+00 : f64
    // CHECK: %[[angle1:.*]] = arith.constant 3.1415926535900001 : f64
    %c0_i32 = arith.constant 0 : i32
    %0 = memref.alloca() : memref<i1>
    %1 = memref.alloca() : memref<i1>
    
    // CHECK: llvm.call @aer_state_configure{{.*$}}
    // CHECK-NEXT: llvm.call @aer_state_configure{{.*$}}
    // CHECK-NEXT: llvm.call @aer_state_configure{{.*$}}

    qcs.init
    qcs.shot_init {qcs.num_shots = 1 : i32}
    %2 = quir.declare_qubit {id = 0 : i32} : !quir.qubit<1>
    // CHECK: %[[q0:.*]] = llvm.call @aer_allocate_qubits{{.*$}}
    %3 = quir.declare_qubit {id = 1 : i32} : !quir.qubit<1>
    // CHECK: %[[q1:.*]] = llvm.call @aer_allocate_qubits{{.*$}}
    quir.builtin_U %2, %angle, %angle_0, %angle_1 : !quir.qubit<1>, !quir.angle<64>, !quir.angle<64>, !quir.angle<64>
    // CHECK: llvm.call @aer_apply_u3({{.*}}, %[[q0]], %[[angle]], %[[angle0]], %[[angle1]]) : (!llvm.ptr<i8>, i64, f64, f64, f64) -> ()
    quir.builtin_CX %2, %3 : !quir.qubit<1>, !quir.qubit<1>
    // CHECK: llvm.call @aer_apply_cx({{.*}}, %[[q0]], %[[q1]]) : (!llvm.ptr<i8>, i64, i64) -> ()
    %4 = quir.measure(%2) : (!quir.qubit<1>) -> i1
    // CHECK: {{.*}} = llvm.call @aer_apply_measure{{.*$}}
    affine.store %4, %1[] : memref<i1>
    %5 = quir.measure(%3) : (!quir.qubit<1>) -> i1
    // CHECK: {{.*}} = llvm.call @aer_apply_measure{{.*$}}
    affine.store %5, %0[] : memref<i1>
    %6 = llvm.mlir.addressof @str_endline : !llvm.ptr<array<2 x i8>>
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %9 = llvm.mlir.addressof @str_digit : !llvm.ptr<array<3 x i8>>
    %10 = llvm.mlir.constant(0 : index) : i64
    %11 = llvm.getelementptr %9[%10, %10] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %12 = llvm.mlir.addressof @str_creg_c0 : !llvm.ptr<array<8 x i8>>
    %13 = llvm.mlir.constant(0 : index) : i64
    %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<8 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %15 = llvm.call @printf(%14) : (!llvm.ptr<i8>) -> i32
    %16 = affine.load %1[] : memref<i1>
    %17 = llvm.call @printf(%11, %16) : (!llvm.ptr<i8>, i1) -> i32
    %18 = llvm.call @printf(%8) : (!llvm.ptr<i8>) -> i32
    %19 = llvm.mlir.addressof @str_creg_c1 : !llvm.ptr<array<8 x i8>>
    %20 = llvm.mlir.constant(0 : index) : i64
    %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<8 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %22 = llvm.call @printf(%21) : (!llvm.ptr<i8>) -> i32
    %23 = affine.load %0[] : memref<i1>
    %24 = llvm.call @printf(%11, %23) : (!llvm.ptr<i8>, i1) -> i32
    %25 = llvm.call @printf(%8) : (!llvm.ptr<i8>) -> i32
    qcs.finalize
    // CHECK: llvm.call @aer_state_finalize{{.*$}}
    return %c0_i32 : i32
  }
}

